using System.Collections.Immutable;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace Godot.SweetWater.SourceGenerator
{
    [Generator]
    public class OverrideNotificationSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            IncrementalValuesProvider<ClassDeclarationSyntax> syntaxProvider =
                context.SyntaxProvider.CreateSyntaxProvider<ClassDeclarationSyntax>(
                    IsTargetSyntaxNode,
                    (syntaxContext, _) => (ClassDeclarationSyntax)syntaxContext.Node
                );
            IncrementalValueProvider<((Compilation Left, ImmutableArray<ClassDeclarationSyntax> Right) Left,
                AnalyzerConfigOptionsProvider Right)> compilationProvider
                = context.CompilationProvider.Combine(syntaxProvider.Collect())
                    .Combine(context.AnalyzerConfigOptionsProvider);
            context.RegisterImplementationSourceOutput(compilationProvider, (productionContext, tuple) =>
            {
                var compilation = tuple.Left.Left;
                ImmutableArray<ClassDeclarationSyntax> nodes = tuple.Left.Right;
                var optionsProvider = tuple.Right;

                foreach (var node in nodes.Distinct())
                {
                    if (productionContext.CancellationToken.IsCancellationRequested) return;

                    var model = compilation.GetSemanticModel(node.SyntaxTree);
                    var classSymbol = model.GetDeclaredSymbol(node);
                    if (classSymbol == null) continue;
                    
                    if (!IsOverridePartialMethodNotification(node)) continue;
                    if (!IsDeclaredVirtualMethodNotification(classSymbol)) continue;

                    // 获取当前类的命名空间
                    string @namespace = classSymbol.ContainingNamespace.ToDisplayString();
                    // 获取当前类的类名
                    string @class = classSymbol.Name;

                    productionContext.AddSource($"{@namespace}.{@class}_OverrideNotification.generated.cs", $@"// <auto-generated/>
using System;
using Godot;

namespace {@namespace}
{{
    public partial class {@class}
    {{
        public override partial void _Notification(int what)
        {{
            GD.Print(""generate code: _Notification"");
        }}
    }}
}}
");
                }
            });
        }

        /// <summary>
        /// 是否是目标语法节点
        /// </summary>
        /// <param name="node">语法节点</param>
        /// <param name="_">_</param>
        /// <returns>是目标语法节点</returns>
        private bool IsTargetSyntaxNode(SyntaxNode node, CancellationToken _)
            => node is ClassDeclarationSyntax type
               && type.BaseList != null
               && type.Modifiers.Select(v => v.Text).Contains("partial");

        /// <summary>
        /// 当前类声明节点是否以分部方法的方式覆盖了了父类中_Notification(int)方法
        /// </summary>
        /// <param name="node">前类声明节点</param>
        /// <returns>覆盖了了父类中_Notification(int)方法</returns>
        private bool IsOverridePartialMethodNotification(ClassDeclarationSyntax node)
        {
            foreach (var member in node.Members)
            {
                if (member is MethodDeclarationSyntax method)
                {
                    SeparatedSyntaxList<ParameterSyntax> parameters = method.ParameterList.Parameters;
                    if (method.Body == null
                        && "_Notification" == method.Identifier.ToString()
                        && method.Modifiers.Select(x => x.Text).Contains("override")
                        && method.Modifiers.Select(x => x.Text).Contains("partial")
                        && parameters.Count == 1
                        && "int" == parameters.First().Type?.ToString())
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        /// <summary>
        /// 父类中是否声明了虚方法：Godot.GodotObject._Notification(int)
        /// </summary>
        /// <param name="symbol">符号</param>
        /// <returns>声明了虚方法Godot.GodotObject._Notification(int)</returns>
        private bool IsDeclaredVirtualMethodNotification(ISymbol? symbol)
        {
            while (symbol != null)
            {
                if (symbol is ITypeSymbol typeSymbol)
                {
                    bool declared = typeSymbol.GetMembers().Any(m =>
                        m.IsVirtual && "Godot.GodotObject._Notification(int)" == m.ToDisplayString()
                    );
                    if (declared) return true;
                    symbol = typeSymbol.BaseType;
                }
                else
                    break;
            }

            return false;
        }
    }
}