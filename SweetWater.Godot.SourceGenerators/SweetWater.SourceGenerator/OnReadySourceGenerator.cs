using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Godot.SweetWater.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public class OnReadySourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValueProvider<ImmutableArray<GeneratorAttributeSyntaxContext>> syntaxProvider = context
            .SyntaxProvider.ForAttributeWithMetadataName(
                typeof(OnReadyAttribute).FullName!,
                static (node, _) =>
                {
                    return node is VariableDeclaratorSyntax
                           || node is PropertyDeclarationSyntax
                           || node is MethodDeclarationSyntax;
                },
                static (context, _) => context
            ).Collect();
        context.RegisterSourceOutput(syntaxProvider, Execute);
    }

    private void Execute(SourceProductionContext spc, ImmutableArray<GeneratorAttributeSyntaxContext> array)
    {
        Dictionary<(string, string), OnReadyModel> dict = new();
        foreach (var gasc in array)
        {
            var targetNode = gasc.TargetNode;
            var classNode = targetNode.Ancestors().OfType<ClassDeclarationSyntax>().FirstOrDefault();
            if (classNode == null) continue;
            if (!CheckClassDeclaration(classNode)) continue;
            var classSymbol = gasc.SemanticModel.GetDeclaredSymbol(classNode);
            if (!IsInheritedFromGodotNode(classSymbol)) continue;

            var targetSymbol = gasc.TargetSymbol;

            var namespaceNode = classNode.Ancestors().OfType<BaseNamespaceDeclarationSyntax>().FirstOrDefault();
            string @namespace = namespaceNode == null ? string.Empty : namespaceNode.Name.ToString();
            string @class = classNode.Identifier.ValueText;

            OnReadyModel model;
            if (!dict.TryGetValue((@namespace, @class), out model))
            {
                model = new OnReadyModel();
                dict[(@namespace, @class)] = model;
            }

            model.Namespace = @namespace;
            model.ClassName = @class;
            model.Modifiers = string.Join(" ", classNode.Modifiers.Select(v => v.ValueText));

            var attributeData = gasc.Attributes.First();
            var nodePath = (string)attributeData.ConstructorArguments[0].Value!;
            if (targetSymbol is IPropertySymbol
                {
                    SetMethod: not null
                } propertySymbol)
            {
                if (!IsInheritedFromGodotNode(propertySymbol.Type)) continue;
                model.Properties.Add(new OnReadyModel.Property()
                {
                    Name = propertySymbol.Name,
                    NodePath = nodePath,
                    Type = propertySymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                });
            }
            else if (targetSymbol is IFieldSymbol fieldSymbol)
            {
                if (!IsInheritedFromGodotNode(fieldSymbol.Type)) continue;
                model.Fields.Add(new OnReadyModel.Field()
                {
                    Name = fieldSymbol.Name,
                    NodePath = nodePath,
                    Type = fieldSymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                });
            }
        }

        foreach (KeyValuePair<(string, string), OnReadyModel> entry in dict)
        {
            var model = entry.Value;
            StringBuilder statements = new();
            List<OnReadyModel.IFieldOrProperty> list =
                model.Fields.Concat(model.Properties.Cast<OnReadyModel.IFieldOrProperty>()).ToList();
            foreach (var item in list)
            {
                var stmt = $"\t\t\t{item.Name} = GetNodeOrNull<{item.Type}>(\"{item.NodePath}\");";
                statements.AppendLine(stmt);
            }

            spc.AddSource($"{model.Namespace}.{model.ClassName}_OverrideNotification.generated.cs",
                $@"// <auto-generated/>
namespace {model.Namespace}
{{
    {model.Modifiers} class {model.ClassName}
    {{
        private void _OnReady()
        {{
{statements.ToString().TrimEnd('\n')}
        }}
    }}
}}
");
        }
    }

    private bool CheckClassDeclaration(SyntaxNode node)
    {
        if (node is not ClassDeclarationSyntax
            {
                Modifiers: var classModifiers and not [],
                BaseList.Types: not []
            })
        {
            return false;
        }

        if (!classModifiers.Any(SyntaxKind.PartialKeyword)) return false;
        if (classModifiers.Any(SyntaxKind.StaticKeyword)) return false;

        return true;
    }

    private bool IsInheritedFromGodotNode(ISymbol? symbol)
    {
        while (symbol != null)
        {
            if (symbol is ITypeSymbol typeSymbol && typeSymbol.TypeKind == TypeKind.Class)
            {
                if (typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).StartsWith("global::Godot.")
                    && typeSymbol.GetMembers().OfType<IMethodSymbol>().Any(v =>
                    {
                        if (v is
                            {
                                Name: "GetNodeOrNull",
                                ReturnsVoid: false,
                                Parameters.Length: 1
                            } methodSymbol
                            && methodSymbol.Parameters[0].Type
                                .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::Godot.NodePath")
                        {
                            return true;
                        }

                        return false;
                    })) return true;
                symbol = typeSymbol.BaseType;
            }
            else
                break;
        }

        return false;
    }
}