using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Godot.SweetWater.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public class OnReadySourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var syntaxProvider = context.CompilationProvider.Combine(
            context.SyntaxProvider.CreateSyntaxProvider(
                    (node, _) => CheckClassDeclaration(node),
                    static (ctx, _) => (ClassDeclarationSyntax)ctx.Node
                ).Collect()
                .Combine(context.SyntaxProvider.ForAttributeWithMetadataName(
                    typeof(OnReadyAttribute).FullName!,
                    static (node, _) =>
                    {
                        return node is VariableDeclaratorSyntax
                               || node is PropertyDeclarationSyntax
                               || node is MethodDeclarationSyntax;
                    },
                    static (context, _) => context
                ).Collect()));

        context.RegisterSourceOutput(syntaxProvider, Execute);
    }

    private void Execute(SourceProductionContext spc,
        (Compilation Left,
            (ImmutableArray<ClassDeclarationSyntax> Left, ImmutableArray<GeneratorAttributeSyntaxContext>Right) Right)
            tuple)
    {
        var compilation = tuple.Left;
        ImmutableArray<ClassDeclarationSyntax> classNodes = tuple.Right.Left;
        ImmutableArray<GeneratorAttributeSyntaxContext> array = tuple.Right.Right;
        Dictionary<(string, string), OnReadyModel> dict = new();

        foreach (var classNode in classNodes)
        {
            var semanticModel = compilation.GetSemanticModel(classNode.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classNode);
            if (!IsInheritedFromGodotNode(classSymbol)) continue;

            var namespaceNode = classNode.Ancestors().OfType<BaseNamespaceDeclarationSyntax>().FirstOrDefault();
            string @namespace = namespaceNode == null ? string.Empty : namespaceNode.Name.ToString();
            string @class = classNode.Identifier.ValueText;

            OnReadyModel model;
            if (!dict.TryGetValue((@namespace, @class), out model))
            {
                model = new OnReadyModel()
                {
                    Namespace = @namespace,
                    ClassName = @class,
                    Modifiers = string.Join(" ", classNode.Modifiers.Select(v => v.ValueText))
                };
                dict[(@namespace, @class)] = model;
            }
        }

        foreach (var gasc in array)
        {
            var targetSymbol = gasc.TargetSymbol;
            var @namespace = gasc.TargetSymbol.ContainingNamespace.ToString();
            string @class = gasc.TargetSymbol.ContainingType.Name;

            OnReadyModel model;
            if (!dict.TryGetValue((@namespace, @class), out model)) continue;

            var attributeData = gasc.Attributes.First();
            var nodePath = (string)attributeData.ConstructorArguments[0].Value!;
            if (targetSymbol is IPropertySymbol
                {
                    SetMethod: not null
                } propertySymbol)
            {
                if (!IsInheritedFromGodotNode(propertySymbol.Type)) continue;
                model.Properties.Add(new OnReadyModel.Property()
                {
                    Name = propertySymbol.Name,
                    NodePath = nodePath,
                    Type = propertySymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                });
            }
            else if (targetSymbol is IFieldSymbol fieldSymbol)
            {
                if (!IsInheritedFromGodotNode(fieldSymbol.Type)) continue;
                model.Fields.Add(new OnReadyModel.Field()
                {
                    Name = fieldSymbol.Name,
                    NodePath = nodePath,
                    Type = fieldSymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                });
            }
        }

        foreach (KeyValuePair<(string, string), OnReadyModel> entry in dict)
        {
            var model = entry.Value;
            StringBuilder statements = new();
            List<OnReadyModel.IFieldOrProperty> list =
                model.Fields.Concat(model.Properties.Cast<OnReadyModel.IFieldOrProperty>()).ToList();
            foreach (var item in list)
            {
                var stmt = $"\t\t\t{item.Name} = GetNodeOrNull<{item.Type}>(\"{item.NodePath}\");";
                statements.AppendLine(stmt);
            }

            spc.AddSource($"{model.Namespace}.{model.ClassName}_OnReady.generated.cs",
                $@"// <auto-generated/>
namespace {model.Namespace}
{{
    {model.Modifiers} class {model.ClassName}
    {{
        private void _OnReady()
        {{
{statements.ToString().TrimEnd('\n')}
        }}
    }}
}}
");
        }
    }

    private bool CheckClassDeclaration(SyntaxNode node)
    {
        if (node is not ClassDeclarationSyntax
            {
                Modifiers: var classModifiers and not [],
                BaseList.Types: not []
            })
        {
            return false;
        }

        if (!classModifiers.Any(SyntaxKind.PartialKeyword)) return false;
        if (classModifiers.Any(SyntaxKind.StaticKeyword)) return false;

        return true;
    }

    private bool IsInheritedFromGodotNode(ISymbol? symbol)
    {
        while (symbol != null)
        {
            if (symbol is ITypeSymbol typeSymbol && typeSymbol.TypeKind == TypeKind.Class)
            {
                if (typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).StartsWith("global::Godot.")
                    && typeSymbol.GetMembers().OfType<IMethodSymbol>().Any(v =>
                    {
                        if (v is
                            {
                                Name: "GetNodeOrNull",
                                ReturnsVoid: false,
                                Parameters.Length: 1
                            } methodSymbol
                            && methodSymbol.Parameters[0].Type
                                .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::Godot.NodePath")
                        {
                            return true;
                        }

                        return false;
                    })) return true;
                symbol = typeSymbol.BaseType;
            }
            else
                break;
        }

        return false;
    }
}